#include "drv_uart.h"



/**
  * @brief :串口初始化
  * @param :无
  * @note  :无
  * @retval:无
  */
 #ifndef max485  
void drv_uart_init( uint32_t UartBaudRate )
{
	//串口引脚配置 TX推挽输出 RX上拉输入
	GPIO_Init( UART_TX_GPIO_PORT, UART_TX_GPIO_PIN,GPIO_MODE_OUT_PP_LOW_SLOW  );
	GPIO_Init( UART_RX_GPIO_PORT, UART_RX_GPIO_PIN,GPIO_MODE_IN_PU_NO_IT );
	
	//USART外设配置
	CLK_PeripheralClockConfig(CLK_PERIPHERAL_UART1, ENABLE);	//使能串口时钟
	UART1_DeInit();		//串口复位
	//串口初始化 8位数据 1个停止位 无校验 发送接收 波特率可变
	UART1_Init( UartBaudRate, UART1_WORDLENGTH_9D, UART1_STOPBITS_1, UART1_PARITY_NO, UART1_SYNCMODE_CLOCK_DISABLE, UART1_MODE_TXRX_ENABLE );
        UART1_ITConfig(UART1_IT_RXNE,ENABLE );        
	UART1_Cmd(ENABLE);	//使能串口
        enableInterrupts(); //开启中断
}
#else
void drv_uart_init_485( uint32_t UartBaudRate )
{
 	//串口引脚配置 TX推挽输出 RX上拉输入
	GPIO_Init( UART_TX_GPIO_PORT, UART_TX_GPIO_PIN,GPIO_MODE_OUT_PP_LOW_SLOW  );
	GPIO_Init( UART_RX_GPIO_PORT, UART_RX_GPIO_PIN,GPIO_MODE_IN_PU_NO_IT );
	
	//USART外设配置
	CLK_PeripheralClockConfig(CLK_PERIPHERAL_UART1, ENABLE);	//使能串口时钟
	UART1_DeInit();		//串口复位
	//串口初始化 8位数据 1个停止位 无校验 发送接收 波特率可变
	UART1_Init( UartBaudRate, UART1_WORDLENGTH_8D, UART1_STOPBITS_1, UART1_PARITY_NO, UART1_SYNCMODE_CLOCK_DISABLE, UART1_MODE_TXRX_ENABLE );
        UART1_ITConfig(UART1_IT_RXNE,ENABLE );        
	UART1_Cmd(ENABLE);	//使能串口
        enableInterrupts(); //开启中断 
}
#endif
/**
  * @brief :串口发送数据
  * @param :
  *			@TxBuffer:发送数据首地址
  *			@Length:数据长度
  * @note  :无
  * @retval:无
  */
void drv_uart_tx_bytes( uint8_t* TxBuffer, uint8_t Length )
{
	while( Length-- )
	{
		while( RESET == UART1_GetFlagStatus(UART1_FLAG_TXE));
		UART1_SendData8( * TxBuffer );
		TxBuffer++;
	}
}

/**
  * @brief :串口接收数据
  * @param :
  *			@RxBuffer:发送数据首地址
  * @note  :无
  * @retval:接收到的字节个数
  */
uint16_t drv_uart_rx_bytes( uint8_t* RxBuffer )
{
	uint16_t l_RxLength = 0;
	uint16_t l_UartRxTimOut = 0xFFF;
	
	while( l_UartRxTimOut-- )			//在超时范围内查询数据
	{
		if( RESET != UART1_GetFlagStatus(UART1_FLAG_RXNE))
		{
			*RxBuffer = UART1_ReceiveData8( );
			RxBuffer++;
			l_RxLength++;
			l_UartRxTimOut = 0xFFF;		//恢复超时等待时间
		}
		if( 512 == l_RxLength )
		{
			break;						//字节不能超过100个字节，由于部分8位机内存较小，接收buffer开得较小
		}
	}
	
	return l_RxLength;					//返回接收到的字节个数
}

